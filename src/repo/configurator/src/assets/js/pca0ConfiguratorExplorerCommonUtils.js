// Copyright (c) 2022 Siemens

/**
 * @module js/pca0ConfiguratorExplorerCommonUtils
 */
import appCtxSvc from 'js/appCtxService';
import { constants as veConstants } from 'js/pca0VariabilityExplorerConstants';
import eventBus from 'js/eventBus';
import htmlUtil from 'js/htmlUtils';
import localeService from 'js/localeService';
import messagingService from 'js/messagingService';
import pca0CommonUtils from 'js/pca0CommonUtils';
import Pca0Constants from 'js/Pca0Constants';
import pca0ContextManagementService from 'js/pca0ContextManagementService';
import tableSvc from 'js/published/splmTablePublishedService';
import _ from 'lodash';


/**
 * Gets the required text once
 * @param {Object} key - i18n key
 * @return {Object} - i18n text
 */
let _get18nText = function( key ) {
    const localeTextBundle = localeService.getLoadedText( 'ConfiguratorExplorerMessages' );
    return localeTextBundle[ key ];
};

/**
 *  Disable checkbox in pick and choose panel
 */
let _disableCheckBox = {
    action: function( column, vmo, tableElem, rowElem ) {
        if ( !vmo.isLeaf && ( vmo.type === Pca0Constants.PSUEDO_GROUPS_UID.UNASSIGNED_GROUP_UID ||
             vmo.modelType && _.intersection( vmo.modelType.typeHierarchyArray, Pca0Constants.CFG_FAMILY_TYPES ).length === 0 ) && rowElem.getElementsByClassName( 'aw-splm-tableCheckBoxPresent' )[0] ) {
            rowElem.getElementsByClassName( 'aw-splm-tableCheckBoxPresent' )[0].style.visibility = 'hidden';
        } else if( vmo.isLeaf && rowElem.getElementsByClassName( 'aw-splm-tableCheckBoxPresent' )[0] ) {
            rowElem.lastElementChild.getElementsByTagName( 'input' )[0].disabled = true;
            rowElem.getElementsByClassName( 'aw-splm-tableCheckBoxPresent' )[0].classList.add( 'aw-cfg-disableCheckBoxClick' );
        }
        return tableSvc.createElement( column, vmo, tableElem, rowElem );
    },
    condition: function( column, vmo ) {
        return vmo.isPreselected;
    },
    name: '_disableCheckBox'
};

/**
 * Gets the dirty renderer
 * @return {Object} - cell content
 */
let _getDirtyRenderer = function() {
    return {
        action: function( column, vmo, tableElem ) {
            let cellContent = tableSvc.createElement( column, vmo, tableElem );
            if( cellContent ) {
                if( cellContent && vmo.isInlineRow ) {
                    cellContent.classList.add( 'aw-cfg-variabilityExplorerCell-dirty' );
                }
                return cellContent;
            }
        },
        condition: function( column, vmo ) {
            return vmo && vmo.isInlineRow && column && column.field === 'object_string';
        },
        name: 'cfgVarExplorerCellDirtyRenderer'
    };
};

/**
 * Gets the required and autogenerated custom renderer
 * @return {Object} - cell content
 */
let _getCustomRenderers = function() {
    return {
        action: function( column, vmo, tableElem ) {
            // Add 'required' only if no content
            // as soon as we get content, remove it
            if( vmo.props[ column.propertyName ] && ( vmo.props[ column.propertyName ].dbValue === null || vmo.props[ column.propertyName ].dbValue === '' ) ) {
                let cellContent = tableSvc.createElement( column, vmo, tableElem );
                var gridCellText = htmlUtil.createElement( 'div', tableSvc.CLASS_WIDGET_TABLE_CELL_TEXT );
                cellContent.classList.add( tableSvc.CLASS_TABLE_CELL_TOP_DYNAMIC );
                gridCellText.classList.add( tableSvc.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC );
                if( column.field === 'object_name' ) {
                    cellContent.classList.add( 'aw-requiredIcon' );
                    // mimic the input placeholder for input and text area
                    gridCellText.textContent = _get18nText( 'required' );
                    gridCellText.classList.add( 'aw-requiredText' );
                } else if( column.field === 'cfg0ObjectId' ) {
                    gridCellText.textContent = _get18nText( 'autogenerated' );
                    gridCellText.classList.add( 'aw-requiredText' );
                    gridCellText.classList.add( 'aw-cfg-autogeneratedText' );
                }
                cellContent.appendChild( gridCellText );
                return cellContent;
            }
        },
        condition: function( column, vmo ) {
            if( !vmo || !column || !vmo.isInlineRow ) {
                return false;
            }
            return column.field === 'cfg0ObjectId' || column.field === 'object_name';
        },
        name: 'cfgVarExplorerCellCustomRenderer'
    };
};

/**
 * Gets the failedToSave inline row renderer
 * @return {Object} - cell content
 */
let _getFailedToSaveInlineRowRenderer = function() {
    return {
        action: function( column, vmo, tableElem, rowElem ) {
            var cellContent = tableSvc.createElement( column, vmo, tableElem, rowElem );

            //LCS-743426 - The cell in Name column should get highlighted after required field popup message
            if( column.field === 'object_name' &&  _.get( vmo.props.object_name, 'isNotAllowedToSave' ) ) {
                cellContent.classList.add( 'aw-cfg-variabilityExplorerCellRequired' );
                delete vmo.props.object_name.isNotAllowedToSave;
            }
            // Add row and cell coloring if inline row still unsaved after trying to save
            if( cellContent && vmo.partialErrorText && column && column.propertyName === 'object_string' ) {
                vmo.indicators = [];
                var cellIndicator = cellContent.getElementsByClassName( 'aw-widgets-gridCellColorContainer' )[ 0 ];
                if( cellIndicator ) {
                    cellIndicator.classList.add( 'aw-cfg-showRedIndicator' );
                    cellIndicator.classList.add( 'aw-cfg-visibleIndicator' );
                    var tooltip = vmo.partialErrorText;
                    cellIndicator.setAttribute( 'title', tooltip );
                }
            }
            return cellContent;
        },
        condition: function( column, vmo, tableElem, rowElem ) {
            if( !vmo || !column || !vmo.isInlineRow ) {
                return false;
            }
            return true;
        },
        name: 'cfgVarExplorerCellFailedToSaveInlineRenderer'
    };
};

/**
 *   Export APIs section starts
 */
let exports = {};

/**
 * Populate Configurator context.
 * If perspective is populated already, return empty context.
 * @param {Object} data the viewModel data
 * @returns {Object} Configurator context
  */
export let populateConfigContext = function( data ) {
    let confContext = '';
    if( !appCtxSvc.getCtx( 'ConfiguratorCtx.configPerspective' ) ) {
        confContext = data.subPanelContext.provider.baseSelection;
    }
    return confContext;
};

/**
 * Update XRT content on SearchState (Atomic Data) - using StandardComponent hierarchy
 * This method is called whenever the selection in PWA changes.
 * The updated selection is received here and SWA accordingly re-renders itself
 * @param {Object} subPanelContext SubPanel context
 */
export const updateXrtContext = ( subPanelContext ) => {
    let searchState = subPanelContext.searchState;
    const newSearchState = searchState ? { ...searchState.getValue() } : undefined;
    if( !_.isUndefined( newSearchState ) ) {
        // createXrtContext
        let contextToSet = {};
        let explorerContext = appCtxSvc.getCtx( veConstants.CONFIG_CONTEXT_KEY );
        contextToSet.configPerspective = explorerContext.configPerspective.uid;
        newSearchState.xrtContext = contextToSet;
        searchState.update( newSearchState );
    }
};

/**
 * Update column details with sorting and filtering flags
 * @param {Object} columns Columns to set filtering and sorting flag
 * @param {Object} columnsToDisableSort List of columns that do not support sorting
 * @param {Object} columnsToDisableFilter List of columns that do not support filtering
 * @returns {Object} updated columns
 */
export let disableColumnSortingAndFiltering = function( columns, columnsToDisableSort, columnsToDisableFilter ) {
    let newColumns = _.cloneDeep( columns );
    _.forEach( newColumns, column => {
        let propertyName = column.propertyName;

        // Attach necessary renderers
        exports.attachRequiredRenderers( column );

        if( columnsToDisableSort ) {
            column.enableSorting = !columnsToDisableSort.includes( propertyName );
        }
        if( columnsToDisableFilter ) {
            column.isFilteringEnabled = !columnsToDisableFilter.includes( propertyName );
        }
    } );
    return newColumns;
};

/**
 * Attach necessary renderers to input column
 * @param {Object} column input column which renderers need to be attached to
 */
export let attachRequiredRenderers = function( column ) {
    // Required renderer is needed (for now until framework supports it):
    // for NAME column on group, family and feature
    // in case of the feature: only on name column for types bool and string - default
    // and on ID vmo for feature of type date, float, int
    column.cellRenderers = [];
    if( column.propertyName === 'object_name' || column.propertyName === 'cfg0ObjectId' ) {
        // Attach required/autogenerated renderer
        column.cellRenderers = [];
        column.cellRenderers.push( _getCustomRenderers() );
    }
    column.cellRenderers.push( _getFailedToSaveInlineRowRenderer() );
    if( column.propertyName === 'object_string' ) {
        // Attach dirty renderer
        column.cellRenderers.push( _getDirtyRenderer() );
        column.cellRenderers.push( _disableCheckBox );
    }
};

/**
 * Gets perspective from Config context
 * @param {string} uidOfLastRule last Rule uid fetched from every performsearch
 * @returns {Object} ConfigPerspectiveUID
 */
export let getInputCriteria = function( uidOfLastRule ) {
    const configuratorCtx = {
        ..._.get( appCtxSvc, 'ctx.' + veConstants.CONFIG_CONTEXT_KEY )
    };
    const perspective = _.get( configuratorCtx, 'configPerspective' );
    let criteria = {
        configPerspective: perspective.uid
    };
    if( !_.isUndefined( uidOfLastRule ) && !_.isEmpty( uidOfLastRule ) ) {
        criteria.uidOfLastRule = uidOfLastRule;
    }
    return criteria;
};

/**
 * Get Configurator Context UID
 * @returns {String} Active Configurator Context UID
 */
export let getConfiguratorContextUID = () => {
    return _.get( appCtxSvc, 'ctx.state.processed.uid' );
};

/**
 * Get Configurator Contexts Map from SessionStorage
 * @returns {Object} Configurator Contexts Map
 */
export let getConfigCtxMapFromSessionStorage = () => {
    var configCtxMapJSON = sessionStorage.getItem( veConstants.CONFIG_CONTEXT_MAP );
    return !_.isNull( configCtxMapJSON ) && !_.isUndefined( configCtxMapJSON ) ? JSON.parse( configCtxMapJSON ) : {};
};

/**
 * Get Constraints Grid Editor Settings from SessionStorage
 * @returns {Object} Grid Editor Settings
 */
export let getConstraintsEditorSettingsMapFromSessionStorage = () => {
    var settingsMapJSON = sessionStorage.getItem( veConstants.CONSTRAINTS_EDITOR_SETTINGS );
    return !_.isNull( settingsMapJSON ) && !_.isUndefined( settingsMapJSON ) ? JSON.parse( settingsMapJSON ) : {};
};

/**
 * Initialize component
 * If Revision Rule was changed in variants tab, sessionStorage has 'appliedSettings' out-of-sync with ConfigPerspective
 * If that's the case, call setProperties and synchronize sessionStorage.
 */
export let initComponent = function() {
    const context = _.get( appCtxSvc, 'ctx.' + veConstants.CONFIG_CONTEXT_KEY );
    const revisionRule = _.get( context, 'appliedSettings.configSettings.props.pca0RevisionRule' );
    let configCtxMap = exports.getConfigCtxMapFromSessionStorage();
    let configuratorContextUID = exports.getConfiguratorContextUID();
    if( configCtxMap.hasOwnProperty( configuratorContextUID ) &&
        configCtxMap[ configuratorContextUID ].isOutOfSyncWithPerspective ) {
        const revRuleUid = revisionRule.dbValues[ 0 ];
        pca0CommonUtils.updateRevisionRuleOnPerspective( veConstants.CONFIG_CONTEXT_KEY, revRuleUid ).then(
            () => {
                pca0ContextManagementService.syncSessionStorage( false );
            },
            function( err ) {
                messagingService.showError( String( err ) );
            } );
    } else {
        eventBus.publish( 'Pca0FilterCriteriaSettings.refreshRevisionRuleContent', revisionRule );
    }
};

/**
 * Get last object from JSON
 * @param {Object} response to get last uid from searchResult
 * @returns {string} returns uid as string from jsonstring
 */
export let getLastUid = function( response ) {
    if( !_.isUndefined( response.ServiceData.plain ) ) {
        const length = response.ServiceData.plain.length;
        return response.ServiceData.plain[ length - 1 ];
    }
    return '';
};

/**
 * Get updated column configuration, disabling sorting and filtering for specified columns
 * @param {Object} response SOA response containing columConfig
 * @param {Array} columnsToDisableSort List of columns that do not support sorting
 * @param {Array} columnsToDisableFilter List of columns that do not support filtering\
 * @param {Array} typesForArrange List of original types for arrange
 * @returns {Object} Updated column configuration
 */
export let getColumnConfig = function( response, columnsToDisableSort, columnsToDisableFilter, typesForArrange ) {
    let newColumnConfig = undefined;
    if( !_.isUndefined( response.columnConfig ) ) {
        newColumnConfig = response.columnConfig;
    } else // This method can be called when Reset column configuration is invoked from resetColumnConfig.
    // So get column configurations from getOrResetUIColumnConfigs3 SOA response.
    {
        newColumnConfig = response.columnConfigurations[ 0 ].columnConfigurations[ 0 ];
        newColumnConfig.typesForArrange = typesForArrange;
    }
    newColumnConfig.columns = exports.disableColumnSortingAndFiltering( newColumnConfig.columns, columnsToDisableSort, columnsToDisableFilter );
    return newColumnConfig;
};

/**
 * Populate unlinkAndDelete input data
 * @param {Array} selectedObjects - user selected objects
 * @return {Array} input data of unlink and delete object
 */
export let unlinkAndDelete = function( selectedObjects ) {
    var input = [];
    var deleteInputData = {};

    for ( var i = 0; i < selectedObjects.length; i++ ) {
        deleteInputData = {
            container: '',
            objectsToDelete: [ selectedObjects[i] ],
            property: '',
            unlinkAlways: false
        };
        input.push( deleteInputData );
    }
    return input;
};

/**
 * Get updated column configuration, disabling sorting and filtering for specified columns
 * @param {Object} soaResponse SOA response containing Allocation objects
 * @param {Object} allocationObjects Allocation object map
 * @returns {Object} Updated column configuration
 */
export let getAllocationObjects = function( soaResponse, allocationObjects ) {
    let nodeToAllocationMap = allocationObjects;
    if( soaResponse.variabilityTreeData && soaResponse.variabilityTreeData.variabiltyNodes ) {
        _.forEach( soaResponse.variabilityTreeData.variabiltyNodes, node =>{
            if( node.props && node.props.associationObject && node.props.associationObject.length > 0 ) {
                nodeToAllocationMap[ node.nodeUid ] = node.props.associationObject[ 0 ];
            }
        } );
    }
    return { ...nodeToAllocationMap };
};

/**
 * To remove already added VMOs from newlyAddedVMOs
 * @param {Object} newlyAddedVMOs - Collection of newly added VMOs from pick and choose panel
 * @param {Object} existingSelection - Collection of existing IDS with familyUid:nodeUid
 * @param {Boolean} createAlternateId - To create collection if not present in existing selections
 *
 *  example:

    Consider subject grid containing following:
                Incl Rule1
    Fam1
        Feat1      TICK
        Feat2      TICK

    Fam2
        Feat4      TICK
    Consider I select Feat3 of Fam1 from Pick And Choose Panel

    The "newlyAddedVMOs" variable will contain - Feat1, Feat2, Feat3, Feat4
    The "existingSelection" variable will contain selection map of Feat1, Feat2, Feat4

    The responsibility of below function is as follows:

    Suppose I collapse Fam1 and Fam2 in grid editor, and if I add Feat3 of Fam1 from Pick and choose Panel:
    Fam1 should get expanded and Fam2 should remain collapsed and I should see something like this:

                Incl Rule1
    Fam1
        Feat1      TICK
        Feat2      TICK
        Feat3      TICK

    Fam2           Feat4

    So, which all objects should I remove from newlyAddedVMOs? I should only remove Feat4 VMO and I should keep Feat1, Feat2, Feat3 VMOs.
    How Do I achieve that? First see the family of newly Added Feature . In my example, I am adding Feat3. The family is Fam1.
    Now, we should not remove any VMO from newlyAddedVMOs belong to Fam1 family.

*/

export let removeSelectedObjects = ( newlyAddedVMOs, existingSelection, createAlternateId ) => {
    // Let's trace the values with my above example

    // exitingAlternateIds are essentially those IDs whose VMOs are not to be added in the tree.
    let existingAlternateIds = [];
    let indexOfExisting = 0;
    // newlyAddedVmoIds - [ Fam1:feat1, Fam1:Feat2, Fam1:Feat3, Fam2:Feat4 ]
    let newlyAddVmoIds = _.map( newlyAddedVMOs, ( newlyAddedVMO ) => {
        return newlyAddedVMO.parentUID + ':' + newlyAddedVMO.nodeUid;
    } );
    if ( createAlternateId ) {
        _.forEach( existingSelection, mapKey => {
            mapKey.parentUID ? existingAlternateIds.push( mapKey.parentUID + ':' +  mapKey.nodeUid ) : false;
        } );
        _.forEach( existingSelection, mapObject => {
            _.forEach( mapObject, objectData => {
                objectData.family ? existingAlternateIds.push( objectData.family + ':' + objectData.nodeUid ) : false;
            } );
        } );
    }

    // existingAlternateIds: [ Fam1:feat1, Fam1:Feat2, Fam2:Feat4 ]
    // existingAlternateIds shouldn't contain Fam1:feat1, Fam1:Feat2. I have to remove those from the array. Below logic is to remove those.

    // newlyAddedFamDiffsIds - [ Fam1 ] . Why Fam1? Because I added Feat1 in Fam1 using Pick and choose.
    let newlyAddedFamDiffIds = _.reduce( newlyAddVmoIds, ( result, newlyAddVmoId ) => {
        if( !existingAlternateIds.includes( newlyAddVmoId ) ) {
            !result.includes( newlyAddVmoId.split( ':' )[ 0 ] ) && result.push( newlyAddVmoId.split( ':' )[ 0 ] );
        }
        return result;
    }, [] );

    // existingAlternateIds - existingAlternateIds should'nt contain any feature belonging to Fam1. Remember that
    // features present in existingAlternateIds will not be added in the tree.
    // exitingAlternateIds - [ Fam2:Feat4 ]. Why Fam2:Feat4? Because Fam2 is collapsed and we shouldn't show Feat4 in tree.
    existingAlternateIds = _.filter( existingAlternateIds, ( existingAlternateId ) => {
        return !newlyAddedFamDiffIds.includes( existingAlternateId.split( ':' )[ 0 ] );
    } );

    const lengthOfExistingOjects = existingAlternateIds.length;
    while ( indexOfExisting < lengthOfExistingOjects ) {
        //const lengthOfNewlyAddedObjects = newlyAddedVMOs.length;
        let startIndexOfNewlyAdded = 0;
        let lastIndexOfNewlyAdded = newlyAddedVMOs.length - 1;
        let removed = false;
        do {
            removed = false;
            const startAlternateID = newlyAddedVMOs[startIndexOfNewlyAdded].alternateID;
            const endAlternateID = newlyAddedVMOs[lastIndexOfNewlyAdded].alternateID;
            const existingAlternateID = existingAlternateIds[indexOfExisting];
            if ( startAlternateID.includes( existingAlternateID ) ) {
                newlyAddedVMOs.splice( startIndexOfNewlyAdded, 1 );
                indexOfExisting++;
                startIndexOfNewlyAdded = 0;
                lastIndexOfNewlyAdded = newlyAddedVMOs.length - 1;
                removed = true;
            } else if( endAlternateID.includes( existingAlternateID ) ) {
                newlyAddedVMOs.splice( lastIndexOfNewlyAdded, 1 );
                indexOfExisting++;
                startIndexOfNewlyAdded = 0;
                lastIndexOfNewlyAdded = newlyAddedVMOs.length - 1;
                removed = true;
            } else {
                startIndexOfNewlyAdded++;
                lastIndexOfNewlyAdded--;
            }
        } while ( startIndexOfNewlyAdded <= lastIndexOfNewlyAdded && indexOfExisting < lengthOfExistingOjects );
        if ( !removed ) {
            indexOfExisting++;
        }
    }
};

export default exports = {
    populateConfigContext,
    updateXrtContext,
    disableColumnSortingAndFiltering,
    attachRequiredRenderers,
    getInputCriteria,
    getConfiguratorContextUID,
    getConfigCtxMapFromSessionStorage,
    getConstraintsEditorSettingsMapFromSessionStorage,
    initComponent,
    getLastUid,
    getColumnConfig,
    unlinkAndDelete,
    getAllocationObjects,
    removeSelectedObjects
};

