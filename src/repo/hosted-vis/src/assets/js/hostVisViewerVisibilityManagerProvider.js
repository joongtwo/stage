// Copyright 2021 Siemens Product Lifecycle Management Software Inc.

/* global define */

/* eslint-disable no-invalid-this */
/* eslint-disable class-methods-use-this */

/**
 * This service is create selection handler for hosted vis
 *
 * @module js/hostVisViewerVisibilityManagerProvider
 */
import appCtxService from 'js/appCtxService';
import _ from 'lodash';
import hostVisQueryService from 'js/hostVisQueryService';
import ViewerVisibilityCoreManager from 'js/viewerVisibilityCoreManager';
import AwPromiseService from 'js/awPromiseService';

/**
 * Class to hold the hosted viewer visibility data
 */
export default class hostVisViewerVisibilityManagerProvider extends ViewerVisibilityCoreManager {
    /**
     * hostVisViewerVisibilityManagerProvider constructor
     */
    constructor() {
        super();
        this._hostedViewerVisibilityChangedListeners = [];
        /**
         * @description Indicates the meaning of the Occurrence's 'keyOrStr' value.
         * @readonly
         * @enum {Number}
         * @memberof JSCom.Consts
         * @see Used in {@link JSCom.EMM.Occurrence}
         */
        this._OccurrenceType = {
            /** A DMUtils key generated by the visualization server that may change each time this model is opened. */
            Key: 0,
            /**
             * A UID that is carefully managed by the TcServer (for example, it remains the same when the BOMLIne is cloned, as the name implies).
             * It is THE way of identifying and persisting an occurrence in TeamCenter.
             */
            CloneStableUIDChain: 1,
            /** A UID value that represents a reference to a server object called an Item Revision. */
            ItemRev: 2,
            /**
             * A property key that is oftentimes identical to CloneStableUIDChain, but differs from the CloneStableUIDChain once
             * a node is cloned.
             */
            OTP: 3,
            /**
             * Similar in usage to 'CloneStableUIDChain' and used when there are only 2 levels in the scene graph.
             * The children of the root are subsets, and each subset contains its ModelElements (part occurrences). So these chains have length 2.
             */
            SubsetUIDChain: 4,
            /*
             * Partitions are not part of strcuture and thus do not have a PS based clone stable chain representation
             * So handle Partition processing separately. BVR partitions UID's will be set in DMUtils to synchronize
             * operations executed on Partitions between AW client and TcVis
             */
            PartitionUIDChain: 5,
            /*
             * Partition Scheme UID, Technically not a Occurrene, but being used as a placeholder for easy of communication with VisServer.
             * Used only to set the active partition scheme. Usage in any other context is not supported.
             */
            PartitionSchemeUID: 6
        };
    }

    /**
     * Initializes host vis manager by setting visibility listener
     */
    initializeHostVisVisibilityManager() {
        this.setupVisibilityListener();
    }

    /**
     * Handle visibility of occurrences from viewer
     *
     * @param {Array} occsFromViewer Array of CSID chain of occurrences
     * @param {Boolean} visibilityToSet visibility to set
     * @param {Boolean} isStateChange is state change
     */
    _handleVisibilityOfOccurrencesFromViewer( occsFromViewer, visibilityToSet, isStateChange ) {
        if( !Array.isArray( occsFromViewer ) || occsFromViewer.length <= 0 ) {
            return;
        }

        var occurrencesFromViewer = [];
        var partitionsFromViewer = [];
        _.forEach( occsFromViewer, function( occurrence ) {
            if( occurrence.type === 1 ) {
                var occCSIDChain = occurrence.theStr;
                if( _.endsWith( occCSIDChain, '/' ) ) {
                    occCSIDChain = occCSIDChain.slice( 0, -1 );
                }
                occurrencesFromViewer.push( occCSIDChain );
            }
        } );

        _.forEach( occsFromViewer, function( occurrence ) {
            if( occurrence.type === 5 ) {
                var occCSIDChain = occurrence.theStr;
                if( _.endsWith( occCSIDChain, '/' ) ) {
                    occCSIDChain = occCSIDChain.slice( 0, -1 );
                }
                partitionsFromViewer.push( occCSIDChain );
            }
        } );

        if( occurrencesFromViewer.length <= 0 ) {
            return;
        }
        //Always process root irrespective of isStateChange.
        if( occurrencesFromViewer.length === 1 && occurrencesFromViewer[ 0 ] === this.ROOT_ID ) {
            this.clearVisibility();
            if( visibilityToSet ) {
                this.invisibleExceptionCsids.push( this.ROOT_ID );
            } else {
                this.invisibleCsids.push( this.ROOT_ID );
            }
        } else {
            if( isStateChange ) {
                this.clearVisibility();
                if( visibilityToSet ) {
                    // If this is state change we need to change Root Visibility because
                    // Viewer does not send notification what parts are turned on/off
                    // when user does Volume and Proximity search.
                    this.invisibleCsids.push( this.ROOT_ID );
                } else {
                    this.invisibleExceptionCsids.push( this.ROOT_ID );
                }
            }
            for( var i = 0; i < occurrencesFromViewer.length; i++ ) {
                this.updateVisibilityAllChildrenOfGivenOccurrence( occurrencesFromViewer[ i ], visibilityToSet );
            }
        }
        let visibilityData = {
            occurrencesFromViewer: occurrencesFromViewer,
            visibilityToSet: visibilityToSet,
            isStateChange: isStateChange,
            invisibleCsids: Object.values( this.invisibleCsids ),
            invisibleExceptionCsids: Object.values( this.invisibleExceptionCsids ),
            invisiblePartitionIds: partitionsFromViewer
        };
        this._notifyViewerVisibilityChanged( visibilityData );
    }

    /**
     * Notify viewer visibility changed listener
     *
     * @param {Array} occurrencesFromViewer Array of CSID chain of occurrences
     */
    _notifyViewerVisibilityChanged( visibilityData ) {
        if( this._hostedViewerVisibilityChangedListeners.length > 0 ) {
            _.forEach( this._hostedViewerVisibilityChangedListeners, function( observer ) {
                observer.call( null, visibilityData );
            } );
        }
    }

    /**
     * Add visibility listener call back function which calls when visibility changes are published from tcVis
     */
    setupVisibilityListener() {
        let self = this;
        let viewerVisibilityListener = {
            visibilityTurnedOn: function( occurrences ) {
                self._handleVisibilityOfOccurrencesFromViewer( occurrences, true, false );
            },
            visibilityTurnedOff: function( occurrences ) {
                self._handleVisibilityOfOccurrencesFromViewer( occurrences, false, false );
            },
            updateVisibleState: function( occurrences ) {
                if( occurrences.length === 0 ) {
                    occurrences.push( { type: 1, theStr: '' } ); //root occurence
                    self._handleVisibilityOfOccurrencesFromViewer( occurrences, false, true );
                } else {
                    self._handleVisibilityOfOccurrencesFromViewer( occurrences, true, true );
                }
            }
        };
        hostVisQueryService.addVisibilityListenr( viewerVisibilityListener );
    }

    /**
     * Add hosted viewer visibility changed listener
     *
     * @param {Object} observerFunction function to be registered
     */
    addViewerVisibilityChangedListener( observerFunction ) {
        if( typeof observerFunction === 'function' ) {
            this._hostedViewerVisibilityChangedListeners.push( observerFunction );
        }
    }

    /**
     * remove hosted viewer visibility changed listener
     *
     * @param {Object} observerFunction function to be removed
     */
    removeViewerVisibilityChangedListener( observerFunction ) {
        if( typeof observerFunction === 'function' ) {
            var indexToBeRemoved = this._hostedViewerVisibilityChangedListeners.indexOf( observerFunction );
            if( indexToBeRemoved > -1 ) {
                this._hostedViewerVisibilityChangedListeners.splice( indexToBeRemoved, 1 );
            }
        }
    }

    /**
     * toggle part viewer visibility
     *
     * @param {String} csidChain csid chain of the model object
     * @returns {Boolean} visibility of product viewer
     */
    toggleProductViewerVisibility( csidChain ) {
        var initialVisibility = this.getProductViewerVisibility( csidChain );
        var finalVisibility = null;
        finalVisibility = this.processVisibility( initialVisibility, finalVisibility, csidChain, true );
        this.setPartsVisibility( [ csidChain ], [], finalVisibility === this.VISIBILITY.VISIBLE, false );
        return finalVisibility;
    }

    /**
     * set part viewer visibility
     *
     * @param {Array} csidChains csid chains of the model objects
     * @param {Array} partitionCsidChains csid chains of the model objects
     * @param {Boolean} isVisible should be made visible or turned off
     * @param {Boolean} isStateChange state change flag to notify
     * @param {Object} visibilityDataCache visibility data cache from other viewer
     *
     * @return {Promise} A promise that is resolved or rejected when the operation has completed.
     */
    setPartsVisibility( csidChains, partitionCsidChains, isVisible, isStateChange, visibilityDataCache ) {
        let occurrences = [];
        _.forEach( csidChains, function( csidChain ) {
            let occ = null;
            if( partitionCsidChains && Array.isArray( partitionCsidChains ) && partitionCsidChains.length > 0 ) {
                if( !_.includes( partitionCsidChains, csidChain ) ) {
                    occ = this.createOccurence( csidChain, this._OccurrenceType.CloneStableUIDChain );
                    occurrences.push( occ );
                }
            } else {
                occ = this.createOccurence( csidChain, this._OccurrenceType.CloneStableUIDChain );
                occurrences.push( occ );
            }
        }.bind( this ) );
        if( partitionCsidChains && Array.isArray( partitionCsidChains ) && partitionCsidChains.length > 0 ) {
            _.forEach( partitionCsidChains, function( prtnCsidChain ) {
                let occ = this.createOccurence( prtnCsidChain, this._OccurrenceType.PartitionUIDChain );
                occurrences.push( occ );
            }.bind( this ) );
        }
        if( csidChains && Array.isArray( csidChains ) && _.includes( csidChains, this.ROOT_ID ) ) {
            this.invisiblePartitionIds.length = 0;
        }
        if( visibilityDataCache ) {
            this.invisibleCsids = visibilityDataCache.invisibleCsids;
            this.invisibleExceptionCsids = visibilityDataCache.invisibleExceptionCsids;
            this.invisiblePartitionIds = visibilityDataCache.invisiblePartitionIds;
        }
        return hostVisQueryService.sendVisibilityToVis( occurrences, isVisible, isStateChange );
    }

    /**
     * Set packed occurence visibility based on the visbility flag input.
     *
     * @param {String} csidChain csid chain of the model object
     * @param {Boolean} visibility Visibility to be applied on the packed occurences.
     */
    setPackedPartsVisibility( csidChain, visibility ) {
        var initialVisibility = this.getProductViewerVisibility( csidChain );
        var finalVisibility = null;
        if( visibility ) {
            finalVisibility = 'VISIBLE';
        } else {
            finalVisibility = 'INVISIBLE';
        }
        this.processVisibility( initialVisibility, finalVisibility, csidChain, false );
        this.setPartsVisibility( [ csidChain ], [], finalVisibility === this.VISIBILITY.VISIBLE, false );
    }

    /**
     * toggle part viewer visibility
     *
     * @param {String} partitionUid csid chain of the model object
     * @returns {Boolean} partitionVisibility
     */
    togglePartitionPartVisibility( partitionUid ) {
        let partitionVisibility = false;
        if( _.includes( this.invisiblePartitionIds, partitionUid ) ) {
            partitionVisibility = true;
            let indexToBeRemoved = this.invisiblePartitionIds.indexOf( partitionUid );
            if( indexToBeRemoved > -1 ) {
                this.invisiblePartitionIds.splice( indexToBeRemoved, 1 );
            }
        } else {
            this.invisiblePartitionIds.push( partitionUid );
        }
        this.setPartitionPartsVisibility( [ partitionUid ], partitionVisibility );
        return partitionVisibility;
    }

    /**
     * set partition part visibility
     *
     * @param {Array} partitionCsidChains csid chains of the model objects
     * @param {Boolean} isVisible should be made visible or turned off
     *
     * @return {Promise} A promise that is resolved or rejected when the operation has completed.
     */
    setPartitionPartsVisibility( partitionCsidChains, isVisible ) {
        var occurrences = [];
        _.forEach( partitionCsidChains, function( prtnCsidChain ) {
            occurrences.push( this.createOccurence( prtnCsidChain, this._OccurrenceType.PartitionUIDChain ) );
        }.bind( this ) );
        return hostVisQueryService.sendVisibilityToVis( occurrences, isVisible, false );
    }

    /**
     * Restore visibility of viewer after connection timeout
     *
     * @param {[String]} invisibles Array of invisible csid strings
     * @param {[String]} invisibleExceptions Array of invisible exception csid strings
     *
     * @returns {Promise} promise thats resolved when visibility is restored
     */
    restoreViewerVisibility( invisibles, invisibleExceptions ) {
        let returnPromise = AwPromiseService.instance.defer();
        let isRootVisible = true;
        this.clearVisibility();
        if( invisibles && Array.isArray( invisibles ) && _.includes( invisibles, this.ROOT_ID ) ) {
            isRootVisible = false;
        }
        if( invisibles && Array.isArray( invisibles ) && invisibles.length > 0 ) {
            for( let i = 0; i < invisibles.length; i++ ) {
                this.invisibleCsids.push( invisibles[ i ] );
            }
        }
        if( invisibleExceptions && Array.isArray( invisibleExceptions ) && invisibleExceptions.length > 0 ) {
            for( let i = 0; i < invisibleExceptions.length; i++ ) {
                this.invisibleExceptionCsids.push( invisibleExceptions[ i ] );
            }
        }
        this.setPartsVisibility( [ this.ROOT_ID ], [], isRootVisible, false ).then(
            function() {
                this._restoreViewerOccVisibility( invisibles, invisibleExceptions ).then( function() {
                    returnPromise.resolve();
                }, function( errorMsg ) {
                    returnPromise.reject( errorMsg );
                } );
            }.bind( this ),
            function( errorMsg ) {
                returnPromise.reject( errorMsg );
            }
        );
        return returnPromise.promise;
    }
    /**
     * Restore visibility of viewer after connection timeout
     *
     * @param {[String]} invisibles Array of invisible csid strings
     * @param {[String]} invisibleExceptions Array of invisible exception csid strings
     *
     * @returns {Promise} promise thats resolved when visibility is restored
     */
    _restoreViewerOccVisibility( invisibles, invisibleExceptions ) {
        var returnPromise = AwPromiseService.instance.defer();
        this._applyVisibility( invisibles, invisibleExceptions ).then( function( nextPassData ) {
            if( !nextPassData ||
                nextPassData.nextInvisibles && _.isEmpty( nextPassData.nextInvisibles ) &&
                ( nextPassData.nextInvisibleExceptions && _.isEmpty( nextPassData.nextInvisibleExceptions ) ) ) {
                returnPromise.resolve();
            } else {
                this._restoreViewerOccVisibility( nextPassData.nextInvisibles, nextPassData.nextInvisibleExceptions ).then(
                    function() {
                        returnPromise.resolve();
                    },
                    function( errorMsg ) {
                        returnPromise.reject( errorMsg );
                    }
                );
            }
        }.bind( this ) );

        return returnPromise.promise;
    }

    /**
     * Apply visibility to parts
     *
     * @param {[String]} invisibles Array of invisible csid strings
     * @param {[String]} invisibleExceptions Array of invisible exception csid strings
     *
     * @returns {Promise} promise thats resolved when visibility is restored
     */
    _applyVisibility( invisibles, invisibleExceptions ) {
        var returnPromise = AwPromiseService.instance.defer();
        if( !invisibles || _.isEmpty( invisibles ) ) {
            if( invisibleExceptions && !_.isEmpty( invisibleExceptions ) ) {
                this.setPartsVisibility( invisibleExceptions, [], true, false ).then(
                    function() {
                        returnPromise.resolve();
                    },
                    function( errorMsg ) {
                        returnPromise.reject( errorMsg );
                    }
                );
            } else {
                returnPromise.resolve();
            }
            return returnPromise.promise;
        }

        if( !invisibleExceptions || _.isEmpty( invisibleExceptions ) ) {
            if( invisibles && !_.isEmpty( invisibles ) ) {
                this.setPartsVisibility( invisibles, [], false, false ).then(
                    function() {
                        returnPromise.resolve();
                    },
                    function( errorMsg ) {
                        returnPromise.reject( errorMsg );
                    }
                );
            } else {
                returnPromise.resolve();
            }
            return returnPromise.promise;
        }

        var nextInvisibles = this.findChildrenOf( invisibleExceptions, invisibles );
        var nextInvisibleExceptions = this.findChildrenOf( invisibles, invisibleExceptions );

        var filteredInvisibles = _.filter( invisibles, function( currInvisibleCsid ) {
            return !_.includes( nextInvisibles, currInvisibleCsid );
        } );

        var filteredInvisiblesExceptions = _.filter( invisibleExceptions, function( currInvisibleExcCsid ) {
            return !_.includes( nextInvisibleExceptions, currInvisibleExcCsid );
        } );

        this.setPartsVisibility( filteredInvisibles, [], false, false ).then(
            function() {
                this.setPartsVisibility( filteredInvisiblesExceptions, [], true, false ).then(
                    function() {
                        returnPromise.resolve( {
                            nextInvisibles: nextInvisibles,
                            nextInvisibleExceptions: nextInvisibleExceptions
                        } );
                    },
                    function( errorMsg ) {
                        returnPromise.reject( errorMsg );
                    }
                );
            }.bind( this ),
            function( errorMsg ) {
                returnPromise.reject( errorMsg );
            }
        );
        return returnPromise.promise;
    }

    /**
     * Get viewer ACE active context
     */
    getAceActiveCtx() {
        return appCtxService.getCtx( this.getOccMgmtContextKey() );
    }

    /**
     *
     * @returns {String} occ mgmt context key
     */
    getOccMgmtContextKey() {
        return appCtxService.ctx.aceActiveContext ? appCtxService.ctx.aceActiveContext.key : 'occmgmtContext';
    }

    /**
     * create occurence
     * @param {String} csidChain csidchain of occurence
     * @param {Number} OccType occurerence type
     * @returns {Object} occurence if csidchain is passed otherwise null
     */
    createOccurence( csidChain, OccType ) {
        let occVisible = {};
        occVisible.type = OccType;
        occVisible.theStr = csidChain;
        if( csidChain.length > 0 ) {
            occVisible.theStr += '/';
        }
        return occVisible;
    }
}
